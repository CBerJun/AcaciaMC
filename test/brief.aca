#*
 * Generic test file for Acacia
 * This file gives you a brief picture of Acacia,
 * while itself is a legal Acacia program.
 *
 * Acacia is written in Python and version 3.6+ is required.
 * No third-party Python package is needed.
 * Compile this (i.e. turn it into MC behavior pack functions) with:
 *   cd path/to/acacia
 *   python main.py -d test/brief.aca
 * "-d" is to show the debugging comments in output files.
 *#

#* Variables *#
# Define a variable `x` and assign 10 to it
x = 10
# Following `+` operator should be calculated during compile time
# `0x` and `0b` can be used to refer to hexadecimal and binary number
x = 0xF2E + 0b11  # `int` type
y = True  # `bool` type

#* Fancy operators *#
# Integer operations: + - * / %
number = (x % -2) * (x + 3)
# Boolean operations: and or not
boolean = y and (x > 10) or (x < 0)

#* Binding *#
scoreboard -> "scb"
# Some values in Acacia are not representable in Minecraft and are only
# for your convenience (e.g. strings). "=" Assignments really creates
# and modifies the values in Minecraft, so its unavailable for these
# kinds of values. In such cases we use binding instead.
player -> "@a[tag=player]"

#* Control statements *#
## If statement
if x > 5:
    x *= 2
# `x` will be doubled only when it's larger than 5

## While loop statement
sum = 0
while x > 0:
    sum += x
    x -= 1
# Sum up numbers from 1 to `x`
# IMPORTANT NOTICE: Loops are implemented through recursion, which runs
# a lot of commands. Minecraft limits the amount of commands that one
# function could trigger to 10000. Be careful when using loops.

## For-in structure & compile time array
# A for-in structure is a "compile time loop" that instructs the
# compiler to *generate repetitive commands* for each iteration. This is
# very different from a while loop (that's a "runtime loop" and is done
# in Minecraft).
m = 10
n = 20
q = 30
# {m, n, q} creates a compile-time array consisting of `m`, `n` and `q`.
arr -> {m, n, q}
# Values from iterator are *bound* to variable so it's possible to do:
# (This will increase `m`, `n` and `q` by 10.)
for i in arr:
    # `i` is local in the for-in scope and can't be accessed from
    # outside.
    i += 10
n = arr.get(0)  # assign value of `m` to `n`.
# Common bisection algorithm implemented with this feature:
y_length = 23
for i in array.geometric(1, ratio=2, times=5).reverse():
    if y_length >= i:
        y_length -= i
        /execute as CBerJun run tp @s ~ ~${i} ~
# `slice` method works the same as Python's slice (start, stop, step)
# and array.range(10) creates {0, 1, 2, ..., 8, 9}.
for i in array.range(10).slice(2, None, 2):
    # `i` is bound to 2, 4, 6 and 8 in turn.
    x += i
# This will increase `x` by 5 for 10 times.
for i in array.repeat(x, 10):
    i += 5

#* Compile-time map *#
# Map is similar to array since it is compile time only.
# Its keys can only be several literal types (e.g. int literal or
# string).
mp -> {0: "zero", 1: "one", 2: "two", 3: "three"}
for i in array.range(4):
    /say ${mp.get(i)}

#* Great builtin modules! *#
#*
 * The builtin modules are actually separated from the compiler itself,
 * which means: everyone can create their own Acacia module!
 * These builtin modules are written in Python at acaciamc/modules
 *#
# To indicate that you are using `print` module
import print
# Tell all players "Hello world!"
print.tell("Hello world!", "@a")
# Show title "Chapter I" on the nearest player's screen, for 10 seconds
print.title("Chapter I", "@p", stay_time=200)
# Show everyone the value of `x` in the form "Value of X: ..." above actionbar
print.title(print.format("Value of X: %0", x), mode=print.ACTIONBAR)
# Introduction to other builtin modules can be found in test/module.aca
# Not only these modules written in Python are supported, Acacia code
# can be imported by other Acacia programs. See test/module.aca

#* Functions *#
# Type of argument or its default value must be specified
def max(a: int, b = int.MAX) -> int:
                    # int.MAX refers to 2147483647
    #* Return the larger one between a and b *#
    if a >= b:
        result a
        # Unlike "return" in modern languages like Python,
        # result statements do not stop functions!
    else:
        result b

def is_larger(a: int, b: int) -> bool:
    #* Return whether a is larger than b *#
    result a > b

if not is_larger(x, 4):
    x = 2
# Comments and empty lines does not affect an indented block
    x = 1 + max(x, 10)
# This elif statement is optimized (1 < 10 is always True)
elif 1 < 10:
    x = 100
else:
    pass  # Empty block

#* Inline functions *#
#*
 * Inline functions have great differences from normal ones.
 * They are like bindings because they are both just an "alias" to make
 * code simpler.
 * Inline functions are:
 *  1. Expanded when called. Every time they get called, their body is
 *  parsed once. Therefore, type of argument can be omitted.
 *  2. Arguments are delivered directly, not assigned. The arguments
 *  are sent in the same way as bindings, while the normal functions
 *  do it using assignments. Therefore, the argument types can be
 *  any type you want.
 *#

inline def my_print(text="Hello!"):
    #* @param text: str *#
    print.tell("Acacia: " + text)
my_print()  # Acacia: Hello!
my_print("Inline functions!")  # Acacia: Inline functions!

inline def set_var(x: int):
    x = 10
set_var(x)  # `x` is 10 now

#* Exported interfaces *#
# These interfaces are exported for later use in Minecraft
interface a:
    # Local variables are unreachable outside scope
    local = 20 < x <= 100  # Chained comparison operators!
    # Do something...
# Now we can use the `a` interface in Minecraft through /function
# command (when using default compile options, it is stored at
# acacia/interface/a.mcfunction)

# The following is generated at acacia/interface/b/c.mcfunction
interface b.c:
    /say b.c called

#* Compatible with the original command system *#
## Accessing scoreboards
# "|" selector ":" objective "|" is referring to selector's score on objective
x = |"@p": "score"| + 10
|"CBerJun": scoreboard| = 3
x = |player: "data"|

## Accessing Raw Command
/say Hello, world!
# Using binding with commands
/tp ${player} 11 45 14
/scoreboard players add ${player} ${scoreboard} 10
/*
tellraw @a {"rawtext":[
    {"text": "Hello "},
    {"text": "world!"}
]}
*/

#* Line continuation using backslash *#
x = \
    10 + int(y)
    # `int` converts boolean to integer.
    # It also refers to the builtin integer type.

# ENJOY!!!
